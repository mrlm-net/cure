package completion

import (
	"context"
	"flag"
	"fmt"
	"sort"
	"strings"

	"github.com/mrlm-net/cure/pkg/terminal"
)

// BashCommand generates a bash completion script by traversing the command registry.
type BashCommand struct {
	registry terminal.CommandRegistry
}

// Name returns "bash".
func (c *BashCommand) Name() string { return "bash" }

// Description returns a short description for bash completion.
func (c *BashCommand) Description() string { return "Generate bash completion script" }

// Usage returns detailed usage information.
func (c *BashCommand) Usage() string {
	return `Usage: cure completion bash

Generate bash completion script for cure commands and flags.

Installation:
  # Install for current session:
  source <(cure completion bash)

  # Install permanently (add to ~/.bashrc):
  cure completion bash >> ~/.bashrc

  # Or install via bash-completion package (Ubuntu/Debian):
  cure completion bash | sudo tee /etc/bash_completion.d/cure

After installation, reload your shell or run:
  source ~/.bashrc

Test it:
  cure <TAB>         # shows all commands
  cure trace <TAB>   # shows http, tcp, udp
`
}

// Flags returns nil â€” the bash command accepts no flags.
func (c *BashCommand) Flags() *flag.FlagSet { return nil }

// Run executes the bash completion generation.
func (c *BashCommand) Run(_ context.Context, tc *terminal.Context) error {
	script := c.generateScript()
	fmt.Fprint(tc.Stdout, script)
	return nil
}

// generateScript builds the bash completion script by introspecting the registry.
func (c *BashCommand) generateScript() string {
	var b strings.Builder

	// Write bash completion function header
	b.WriteString("# bash completion for cure\n")
	b.WriteString("# Generated by: cure completion bash\n\n")
	b.WriteString("_cure_completions() {\n")
	b.WriteString("  local cur prev words cword\n")
	b.WriteString("  _init_completion || return\n\n")

	// Extract commands and flags from registry
	commands := c.collectCommands()
	subcommands := c.collectSubcommands()
	flags := c.collectFlags()

	// Generate command completion logic
	b.WriteString("  # Command completion\n")
	b.WriteString("  if [[ ${cword} -eq 1 ]]; then\n")
	b.WriteString(fmt.Sprintf("    COMPREPLY=($(compgen -W '%s' -- \"${cur}\"))\n", strings.Join(commands, " ")))
	b.WriteString("    return 0\n")
	b.WriteString("  fi\n\n")

	// Generate subcommand completion logic
	if len(subcommands) > 0 {
		b.WriteString("  # Subcommand completion\n")
		b.WriteString("  if [[ ${cword} -eq 2 ]]; then\n")
		b.WriteString("    case ${words[1]} in\n")
		for parent, subs := range subcommands {
			b.WriteString(fmt.Sprintf("      %s)\n", parent))
			b.WriteString(fmt.Sprintf("        COMPREPLY=($(compgen -W '%s' -- \"${cur}\"))\n", strings.Join(subs, " ")))
			b.WriteString("        return 0\n")
			b.WriteString("        ;;\n")
		}
		b.WriteString("    esac\n")
		b.WriteString("  fi\n\n")
	}

	// Generate flag value completion logic
	if len(FlagValues) > 0 {
		b.WriteString("  # Flag value completion\n")
		b.WriteString("  case ${prev} in\n")
		for flagName, values := range FlagValues {
			b.WriteString(fmt.Sprintf("    --%s)\n", flagName))
			b.WriteString(fmt.Sprintf("      COMPREPLY=($(compgen -W '%s' -- \"${cur}\"))\n", strings.Join(values, " ")))
			b.WriteString("      return 0\n")
			b.WriteString("      ;;\n")
		}
		b.WriteString("  esac\n\n")
	}

	// Default flag name completion
	b.WriteString("  # Flag name completion\n")
	b.WriteString("  if [[ ${cur} == -* ]]; then\n")
	if len(flags) > 0 {
		b.WriteString(fmt.Sprintf("    COMPREPLY=($(compgen -W '%s' -- \"${cur}\"))\n", strings.Join(flags, " ")))
	}
	b.WriteString("    return 0\n")
	b.WriteString("  fi\n")

	b.WriteString("}\n\n")
	b.WriteString("complete -F _cure_completions cure\n")

	return b.String()
}

// collectCommands extracts all top-level command names from the registry.
func (c *BashCommand) collectCommands() []string {
	var names []string
	for _, cmd := range c.registry.Commands() {
		names = append(names, cmd.Name())
	}
	sort.Strings(names)
	return names
}

// collectSubcommands extracts subcommands from nested routers.
// Returns a map of parent command name -> list of subcommand names.
func (c *BashCommand) collectSubcommands() map[string][]string {
	subcommands := make(map[string][]string)

	for _, cmd := range c.registry.Commands() {
		// Check if command is a Router (has subcommands)
		if router, ok := cmd.(*terminal.Router); ok {
			var subNames []string
			for _, subCmd := range router.Commands() {
				subNames = append(subNames, subCmd.Name())
			}
			if len(subNames) > 0 {
				sort.Strings(subNames)
				subcommands[cmd.Name()] = subNames
			}
		}
	}

	return subcommands
}

// collectFlags extracts all flag names from registered commands.
func (c *BashCommand) collectFlags() []string {
	var flags []string
	seen := make(map[string]bool)

	var collectFromCommand func(cmd terminal.Command)
	collectFromCommand = func(cmd terminal.Command) {
		if fs := cmd.Flags(); fs != nil {
			fs.VisitAll(func(f *flag.Flag) {
				flagName := "--" + f.Name
				if !seen[flagName] {
					seen[flagName] = true
					flags = append(flags, flagName)
				}
			})
		}

		// Recurse into sub-routers
		if router, ok := cmd.(*terminal.Router); ok {
			for _, subCmd := range router.Commands() {
				collectFromCommand(subCmd)
			}
		}
	}

	for _, cmd := range c.registry.Commands() {
		collectFromCommand(cmd)
	}

	sort.Strings(flags)
	return flags
}
