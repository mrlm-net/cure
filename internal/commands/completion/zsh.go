package completion

import (
	"context"
	"flag"
	"fmt"
	"sort"
	"strings"

	"github.com/mrlm-net/cure/pkg/terminal"
)

// ZshCommand generates a zsh completion script by traversing the command registry.
type ZshCommand struct {
	registry terminal.CommandRegistry
}

// Name returns "zsh".
func (c *ZshCommand) Name() string { return "zsh" }

// Description returns a short description for zsh completion.
func (c *ZshCommand) Description() string { return "Generate zsh completion script" }

// Usage returns detailed usage information.
func (c *ZshCommand) Usage() string {
	return `Usage: cure completion zsh

Generate zsh completion script for cure commands and flags.

Installation:
  # Install for current session:
  source <(cure completion zsh)

  # Install permanently (add to ~/.zshrc):
  cure completion zsh > "${fpath[1]}/_cure"
  # Then reload completions:
  compinit

After installation, reload your shell or run:
  exec zsh

Test it:
  cure <TAB>         # shows all commands
  cure trace <TAB>   # shows http, tcp, udp
`
}

// Flags returns nil â€” the zsh command accepts no flags.
func (c *ZshCommand) Flags() *flag.FlagSet { return nil }

// Run executes the zsh completion generation.
func (c *ZshCommand) Run(_ context.Context, tc *terminal.Context) error {
	script := c.generateScript()
	fmt.Fprint(tc.Stdout, script)
	return nil
}

// generateScript builds the zsh completion script by introspecting the registry.
func (c *ZshCommand) generateScript() string {
	var b strings.Builder

	b.WriteString("#compdef cure\n")
	b.WriteString("# zsh completion for cure\n")
	b.WriteString("# Generated by: cure completion zsh\n\n")

	b.WriteString("_cure() {\n")
	b.WriteString("  local -a commands\n")
	b.WriteString("  commands=(\n")

	// List commands with descriptions
	cmds := c.registry.Commands()
	sort.Slice(cmds, func(i, j int) bool {
		return cmds[i].Name() < cmds[j].Name()
	})

	for _, cmd := range cmds {
		desc := escapeZshDesc(cmd.Description())
		b.WriteString(fmt.Sprintf("    '%s:%s'\n", cmd.Name(), desc))
	}

	b.WriteString("  )\n\n")

	// Set up argument parsing
	b.WriteString("  _arguments \\\n")
	b.WriteString("    '1: :->command' \\\n")
	b.WriteString("    '*::arg:->args'\n\n")

	b.WriteString("  case $state in\n")
	b.WriteString("    command)\n")
	b.WriteString("      _describe 'cure commands' commands\n")
	b.WriteString("      ;;\n")
	b.WriteString("    args)\n")
	b.WriteString("      case $words[1] in\n")

	// Generate per-command argument and flag completion
	for _, cmd := range cmds {
		b.WriteString(fmt.Sprintf("        %s)\n", cmd.Name()))

		// Check if this is a router with subcommands
		if router, ok := cmd.(*terminal.Router); ok {
			subCmds := router.Commands()
			if len(subCmds) > 0 {
				b.WriteString("          local -a subcommands\n")
				b.WriteString("          subcommands=(\n")
				sort.Slice(subCmds, func(i, j int) bool {
					return subCmds[i].Name() < subCmds[j].Name()
				})
				for _, subCmd := range subCmds {
					desc := escapeZshDesc(subCmd.Description())
					b.WriteString(fmt.Sprintf("            '%s:%s'\n", subCmd.Name(), desc))
				}
				b.WriteString("          )\n")
				b.WriteString("          _describe 'subcommands' subcommands\n")
			}
		}

		// Add flag completion if command has flags
		if fs := cmd.Flags(); fs != nil {
			var flagLines []string
			fs.VisitAll(func(f *flag.Flag) {
				desc := escapeZshDesc(f.Usage)
				// Check if flag has predefined values
				if values, ok := FlagValues[f.Name]; ok {
					valueList := strings.Join(values, " ")
					flagLines = append(flagLines, fmt.Sprintf("            '--%s[%s]:value:(%s)'", f.Name, desc, valueList))
				} else {
					flagLines = append(flagLines, fmt.Sprintf("            '--%s[%s]'", f.Name, desc))
				}
			})
			if len(flagLines) > 0 {
				b.WriteString("          _arguments \\\n")
				for _, line := range flagLines {
					b.WriteString(line + " \\\n")
				}
			}
		}

		b.WriteString("          ;;\n")
	}

	b.WriteString("      esac\n")
	b.WriteString("      ;;\n")
	b.WriteString("  esac\n")
	b.WriteString("}\n\n")
	b.WriteString("_cure\n")

	return b.String()
}

// escapeZshDesc escapes special characters in zsh completion descriptions.
// Zsh uses colons as separators, so they must be escaped.
func escapeZshDesc(desc string) string {
	desc = strings.ReplaceAll(desc, ":", "\\:")
	desc = strings.ReplaceAll(desc, "'", "\\'")
	desc = strings.ReplaceAll(desc, "[", "\\[")
	desc = strings.ReplaceAll(desc, "]", "\\]")
	return desc
}
